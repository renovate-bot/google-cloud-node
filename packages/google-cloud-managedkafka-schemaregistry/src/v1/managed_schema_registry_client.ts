// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **

/* global window */
import type * as gax from 'google-gax';
import type {Callback, CallOptions, Descriptors, ClientOptions, LocationsClient, LocationProtos} from 'google-gax';

import * as protos from '../../protos/protos';
import jsonProtos = require('../../protos/protos.json');
import {loggingUtils as logging, decodeAnyProtosInArray} from 'google-gax';

/**
 * Client JSON configuration object, loaded from
 * `src/v1/managed_schema_registry_client_config.json`.
 * This file defines retry strategy and timeouts for all API methods in this library.
 */
import * as gapicConfig from './managed_schema_registry_client_config.json';
const version = require('../../../package.json').version;

/**
 *  SchemaRegistry is a service that allows users to manage schemas for their
 *  Kafka clusters. It provides APIs to register, list, and delete schemas, as
 *  well as to get the schema for a given schema id or a given version id under a
 *  subject, to update the global or subject-specific compatibility mode, and to
 *  check the compatibility of a schema against a subject or a version. The main
 *  resource hierarchy is as follows:
 *
 *  * SchemaRegistry
 *  * SchemaRegistry/Context
 *  * SchemaRegistry/Context/Schema
 *  * SchemaRegistry/Context/Subject
 *  * SchemaRegistry/Context/Subject/Version
 *  * SchemaRegistry/Config
 *  * SchemaRegistry/Mode
 *
 *  **SchemaRegistry** is the root resource to represent a schema registry
 *  instance. A customer can have multiple schema registry instances in a
 *  project.
 *
 *  **Context** is a context resource that represents a group of
 *  schemas, subjects and versions. A schema registry instance can have multiple
 *  contexts and always has a 'default' context. Contexts are independent of each
 *  other. Context is optional and if not specified, it falls back to the
 *  'default' context.
 *
 *  **Schema** is a schema resource that represents a unique schema in a context
 *  of a schema registry instance. Each schema has a unique schema id, and can be
 *  referenced by a version of a subject.
 *
 *  **Subject** refers to the name under which the schema is registered. A
 *  typical subject is the Kafka topic name. A schema registry instance can have
 *  multiple subjects.
 *
 *  **Version** represents a version of a subject. A subject can have multiple
 *  versions. Creation of new version of a subject is guarded by the
 *  compatibility mode configured globally or for the subject specifically.
 *
 *  **Config** represents a config at global level cross all registry
 *  instances or at subject level. Currently, only compatibility is supported in
 *  config.
 *
 *  **Mode** represents the mode of a schema registry or a specific subject.
 *  Three modes are supported:
 *  * READONLY: The schema registry is in read-only mode, no write operations
 *  allowed..
 *  * READWRITE: The schema registry is in read-write mode, which allows limited
 *  write operations on the schema.
 *  * IMPORT: The schema registry is in import mode, which allows more editing
 *  operations on the schema for data importing purposes.
 * @class
 * @memberof v1
 */
export class ManagedSchemaRegistryClient {
  private _terminated = false;
  private _opts: ClientOptions;
  private _providedCustomServicePath: boolean;
  private _gaxModule: typeof gax | typeof gax.fallback;
  private _gaxGrpc: gax.GrpcClient | gax.fallback.GrpcClient;
  private _protos: {};
  private _defaults: {[method: string]: gax.CallSettings};
  private _universeDomain: string;
  private _servicePath: string;
  private _log = logging.log('managedkafka-schemaregistry');

  auth: gax.GoogleAuth;
  descriptors: Descriptors = {
    page: {},
    stream: {},
    longrunning: {},
    batching: {},
  };
  warn: (code: string, message: string, warnType?: string) => void;
  innerApiCalls: {[name: string]: Function};
  locationsClient: LocationsClient;
  pathTemplates: {[name: string]: gax.PathTemplate};
  managedSchemaRegistryStub?: Promise<{[name: string]: Function}>;

  /**
   * Construct an instance of ManagedSchemaRegistryClient.
   *
   * @param {object} [options] - The configuration object.
   * The options accepted by the constructor are described in detail
   * in [this document](https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#creating-the-client-instance).
   * The common options are:
   * @param {object} [options.credentials] - Credentials object.
   * @param {string} [options.credentials.client_email]
   * @param {string} [options.credentials.private_key]
   * @param {string} [options.email] - Account email address. Required when
   *     using a .pem or .p12 keyFilename.
   * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or
   *     .p12 key downloaded from the Google Developers Console. If you provide
   *     a path to a JSON file, the projectId option below is not necessary.
   *     NOTE: .pem and .p12 require you to specify options.email as well.
   * @param {number} [options.port] - The port on which to connect to
   *     the remote host.
   * @param {string} [options.projectId] - The project ID from the Google
   *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check
   *     the environment variable GCLOUD_PROJECT for your project ID. If your
   *     app is running in an environment which supports
   *     {@link https://cloud.google.com/docs/authentication/application-default-credentials Application Default Credentials},
   *     your project ID will be detected automatically.
   * @param {string} [options.apiEndpoint] - The domain name of the
   *     API remote host.
   * @param {gax.ClientConfig} [options.clientConfig] - Client configuration override.
   *     Follows the structure of {@link gapicConfig}.
   * @param {boolean} [options.fallback] - Use HTTP/1.1 REST mode.
   *     For more information, please check the
   *     {@link https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#http11-rest-api-mode documentation}.
   * @param {gax} [gaxInstance]: loaded instance of `google-gax`. Useful if you
   *     need to avoid loading the default gRPC version and want to use the fallback
   *     HTTP implementation. Load only fallback version and pass it to the constructor:
   *     ```
   *     const gax = require('google-gax/build/src/fallback'); // avoids loading google-gax with gRPC
   *     const client = new ManagedSchemaRegistryClient({fallback: true}, gax);
   *     ```
   */
  constructor(opts?: ClientOptions, gaxInstance?: typeof gax | typeof gax.fallback) {
    // Ensure that options include all the required fields.
    const staticMembers = this.constructor as typeof ManagedSchemaRegistryClient;
    if (opts?.universe_domain && opts?.universeDomain && opts?.universe_domain !== opts?.universeDomain) {
      throw new Error('Please set either universe_domain or universeDomain, but not both.');
    }
    const universeDomainEnvVar = (typeof process === 'object' && typeof process.env === 'object') ? process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] : undefined;
    this._universeDomain = opts?.universeDomain ?? opts?.universe_domain ?? universeDomainEnvVar ?? 'googleapis.com';
    this._servicePath = 'managedkafka.' + this._universeDomain;
    const servicePath = opts?.servicePath || opts?.apiEndpoint || this._servicePath;
    this._providedCustomServicePath = !!(opts?.servicePath || opts?.apiEndpoint);
    const port = opts?.port || staticMembers.port;
    const clientConfig = opts?.clientConfig ?? {};
    const fallback = opts?.fallback ?? (typeof window !== 'undefined' && typeof window?.fetch === 'function');
    opts = Object.assign({servicePath, port, clientConfig, fallback}, opts);

    // Request numeric enum values if REST transport is used.
    opts.numericEnums = true;

    // If scopes are unset in options and we're connecting to a non-default endpoint, set scopes just in case.
    if (servicePath !== this._servicePath && !('scopes' in opts)) {
      opts['scopes'] = staticMembers.scopes;
    }

    // Load google-gax module synchronously if needed
    if (!gaxInstance) {
      gaxInstance = require('google-gax') as typeof gax;
    }

    // Choose either gRPC or proto-over-HTTP implementation of google-gax.
    this._gaxModule = opts.fallback ? gaxInstance.fallback : gaxInstance;

    // Create a `gaxGrpc` object, with any grpc-specific options sent to the client.
    this._gaxGrpc = new this._gaxModule.GrpcClient(opts);

    // Save options to use in initialize() method.
    this._opts = opts;

    // Save the auth object to the client, for use by other methods.
    this.auth = (this._gaxGrpc.auth as gax.GoogleAuth);

    // Set useJWTAccessWithScope on the auth object.
    this.auth.useJWTAccessWithScope = true;

    // Set defaultServicePath on the auth object.
    this.auth.defaultServicePath = this._servicePath;

    // Set the default scopes in auth client if needed.
    if (servicePath === this._servicePath) {
      this.auth.defaultScopes = staticMembers.scopes;
    }
    this.locationsClient = new this._gaxModule.LocationsClient(
      this._gaxGrpc,
      opts
    );
  

    // Determine the client header string.
    const clientHeader = [
      `gax/${this._gaxModule.version}`,
      `gapic/${version}`,
    ];
    if (typeof process === 'object' && 'versions' in process) {
      clientHeader.push(`gl-node/${process.versions.node}`);
    } else {
      clientHeader.push(`gl-web/${this._gaxModule.version}`);
    }
    if (!opts.fallback) {
      clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);
    } else {
      clientHeader.push(`rest/${this._gaxGrpc.grpcVersion}`);
    }
    if (opts.libName && opts.libVersion) {
      clientHeader.push(`${opts.libName}/${opts.libVersion}`);
    }
    // Load the applicable protos.
    this._protos = this._gaxGrpc.loadProtoJSON(jsonProtos);

    // This API contains "path templates"; forward-slash-separated
    // identifiers to uniquely identify resources within the API.
    // Create useful helper objects for these.
    this.pathTemplates = {
      projectLocationSchemaRegistryCompatibilitySubjectVersionsPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/{subject}/versions/{version}'
      ),
      projectLocationSchemaRegistryConfigPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config'
      ),
      projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/compatibility/subjects/{subject}/versions/{version}'
      ),
      projectLocationSchemaRegistryContextConfigPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/config'
      ),
      projectLocationSchemaRegistryContextModePathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode'
      ),
      projectLocationSchemaRegistryContextSchemasPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}'
      ),
      projectLocationSchemaRegistryContextSubjectPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}'
      ),
      projectLocationSchemaRegistryContextSubjectVersionsPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}'
      ),
      projectLocationSchemaRegistryContextSubjectsPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}'
      ),
      projectLocationSchemaRegistryModePathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode'
      ),
      projectLocationSchemaRegistrySchemasPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}'
      ),
      projectLocationSchemaRegistrySubjectPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}'
      ),
      projectLocationSchemaRegistrySubjectVersionsPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}'
      ),
      projectLocationSchemaRegistrySubjectsPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}'
      ),
      schemaContextPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}'
      ),
      schemaRegistryPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/schemaRegistries/{schema_registry}'
      ),
    };

    // Put together the default options sent with requests.
    this._defaults = this._gaxGrpc.constructSettings(
        'google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry', gapicConfig as gax.ClientConfig,
        opts.clientConfig || {}, {'x-goog-api-client': clientHeader.join(' ')});

    // Set up a dictionary of "inner API calls"; the core implementation
    // of calling the API is handled in `google-gax`, with this code
    // merely providing the destination and request information.
    this.innerApiCalls = {};

    // Add a warn function to the client constructor so it can be easily tested.
    this.warn = this._gaxModule.warn;
  }

  /**
   * Initialize the client.
   * Performs asynchronous operations (such as authentication) and prepares the client.
   * This function will be called automatically when any class method is called for the
   * first time, but if you need to initialize it before calling an actual method,
   * feel free to call initialize() directly.
   *
   * You can await on this method if you want to make sure the client is initialized.
   *
   * @returns {Promise} A promise that resolves to an authenticated service stub.
   */
  initialize() {
    // If the client stub promise is already initialized, return immediately.
    if (this.managedSchemaRegistryStub) {
      return this.managedSchemaRegistryStub;
    }

    // Put together the "service stub" for
    // google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry.
    this.managedSchemaRegistryStub = this._gaxGrpc.createStub(
        this._opts.fallback ?
          (this._protos as protobuf.Root).lookupService('google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry') :
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (this._protos as any).google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry,
        this._opts, this._providedCustomServicePath) as Promise<{[method: string]: Function}>;

    // Iterate over each of the methods that the service provides
    // and create an API call method for each.
    const managedSchemaRegistryStubMethods =
        ['getSchemaRegistry', 'listSchemaRegistries', 'createSchemaRegistry', 'deleteSchemaRegistry', 'getContext', 'listContexts', 'getSchema', 'getRawSchema', 'listSchemaVersions', 'listSchemaTypes', 'listSubjects', 'listSubjectsBySchemaId', 'deleteSubject', 'lookupVersion', 'getVersion', 'getRawSchemaVersion', 'listVersions', 'createVersion', 'deleteVersion', 'listReferencedSchemas', 'checkCompatibility', 'getSchemaConfig', 'updateSchemaConfig', 'deleteSchemaConfig', 'getSchemaMode', 'updateSchemaMode', 'deleteSchemaMode'];
    for (const methodName of managedSchemaRegistryStubMethods) {
      const callPromise = this.managedSchemaRegistryStub.then(
        stub => (...args: Array<{}>) => {
          if (this._terminated) {
            return Promise.reject('The client has already been closed.');
          }
          const func = stub[methodName];
          return func.apply(stub, args);
        },
        (err: Error|null|undefined) => () => {
          throw err;
        });

      const descriptor =
        undefined;
      const apiCall = this._gaxModule.createApiCall(
        callPromise,
        this._defaults[methodName],
        descriptor,
        this._opts.fallback
      );

      this.innerApiCalls[methodName] = apiCall;
    }

    return this.managedSchemaRegistryStub;
  }

  /**
   * The DNS address for this API service.
   * @deprecated Use the apiEndpoint method of the client instance.
   * @returns {string} The DNS address for this service.
   */
  static get servicePath() {
    if (typeof process === 'object' && typeof process.emitWarning === 'function') {
      process.emitWarning('Static servicePath is deprecated, please use the instance method instead.', 'DeprecationWarning');
    }
    return 'managedkafka.googleapis.com';
  }

  /**
   * The DNS address for this API service - same as servicePath.
   * @deprecated Use the apiEndpoint method of the client instance.
   * @returns {string} The DNS address for this service.
   */
  static get apiEndpoint() {
    if (typeof process === 'object' && typeof process.emitWarning === 'function') {
      process.emitWarning('Static apiEndpoint is deprecated, please use the instance method instead.', 'DeprecationWarning');
    }
    return 'managedkafka.googleapis.com';
  }

  /**
   * The DNS address for this API service.
   * @returns {string} The DNS address for this service.
   */
  get apiEndpoint() {
    return this._servicePath;
  }

  get universeDomain() {
    return this._universeDomain;
  }

  /**
   * The port for this API service.
   * @returns {number} The default port for this service.
   */
  static get port() {
    return 443;
  }

  /**
   * The scopes needed to make gRPC calls for every method defined
   * in this service.
   * @returns {string[]} List of default scopes.
   */
  static get scopes() {
    return [
      'https://www.googleapis.com/auth/cloud-platform'
    ];
  }

  getProjectId(): Promise<string>;
  getProjectId(callback: Callback<string, undefined, undefined>): void;
  /**
   * Return the project ID used by this class.
   * @returns {Promise} A promise that resolves to string containing the project ID.
   */
  getProjectId(callback?: Callback<string, undefined, undefined>):
      Promise<string>|void {
    if (callback) {
      this.auth.getProjectId(callback);
      return;
    }
    return this.auth.getProjectId();
  }

  // -------------------
  // -- Service calls --
  // -------------------
/**
 * Get the schema registry instance.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.name
 *   Required. The name of the schema registry instance to return. Structured
 *   like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.cloud.managedkafka.schemaregistry.v1.SchemaRegistry|SchemaRegistry}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.get_schema_registry.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_GetSchemaRegistry_async
 */
  getSchemaRegistry(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRegistryRequest,
      options?: CallOptions):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRegistryRequest|undefined, {}|undefined
      ]>;
  getSchemaRegistry(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRegistryRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRegistryRequest|null|undefined,
          {}|null|undefined>): void;
  getSchemaRegistry(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRegistryRequest,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRegistryRequest|null|undefined,
          {}|null|undefined>): void;
  getSchemaRegistry(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRegistryRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRegistryRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRegistryRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRegistryRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'name': request.name ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('getSchemaRegistry request %j', request);
    const wrappedCallback: Callback<
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRegistryRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('getSchemaRegistry response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.getSchemaRegistry(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRegistryRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('getSchemaRegistry response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * List schema registries.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.parent
 *   Required. The parent whose schema registry instances are to be listed.
 *   Structured like: `projects/{project}/locations/{location}`
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.cloud.managedkafka.schemaregistry.v1.ListSchemaRegistriesResponse|ListSchemaRegistriesResponse}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.list_schema_registries.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_ListSchemaRegistries_async
 */
  listSchemaRegistries(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesRequest,
      options?: CallOptions):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesResponse,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesRequest|undefined, {}|undefined
      ]>;
  listSchemaRegistries(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesResponse,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesRequest|null|undefined,
          {}|null|undefined>): void;
  listSchemaRegistries(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesRequest,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesResponse,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesRequest|null|undefined,
          {}|null|undefined>): void;
  listSchemaRegistries(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesResponse,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesResponse,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesResponse,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'parent': request.parent ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('listSchemaRegistries request %j', request);
    const wrappedCallback: Callback<
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesResponse,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('listSchemaRegistries response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.listSchemaRegistries(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesResponse,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('listSchemaRegistries response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Create a schema registry instance.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.parent
 *   Required. The parent whose schema registry instance is to be created.
 *   Structured like: `projects/{project}/locations/{location}`
 * @param {string} request.schemaRegistryId
 *   Required. The schema registry instance ID to use for this schema registry.
 *   The ID must contain only letters (a-z, A-Z), numbers (0-9), and underscores
 *   (-). The maximum length is 63 characters.
 *   The ID must not start with a number.
 * @param {google.cloud.managedkafka.schemaregistry.v1.SchemaRegistry} request.schemaRegistry
 *   Required. The schema registry instance to create.
 *   The name field is ignored.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.cloud.managedkafka.schemaregistry.v1.SchemaRegistry|SchemaRegistry}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.create_schema_registry.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_CreateSchemaRegistry_async
 */
  createSchemaRegistry(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.ICreateSchemaRegistryRequest,
      options?: CallOptions):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry,
        protos.google.cloud.managedkafka.schemaregistry.v1.ICreateSchemaRegistryRequest|undefined, {}|undefined
      ]>;
  createSchemaRegistry(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.ICreateSchemaRegistryRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry,
          protos.google.cloud.managedkafka.schemaregistry.v1.ICreateSchemaRegistryRequest|null|undefined,
          {}|null|undefined>): void;
  createSchemaRegistry(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.ICreateSchemaRegistryRequest,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry,
          protos.google.cloud.managedkafka.schemaregistry.v1.ICreateSchemaRegistryRequest|null|undefined,
          {}|null|undefined>): void;
  createSchemaRegistry(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.ICreateSchemaRegistryRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry,
          protos.google.cloud.managedkafka.schemaregistry.v1.ICreateSchemaRegistryRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry,
          protos.google.cloud.managedkafka.schemaregistry.v1.ICreateSchemaRegistryRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry,
        protos.google.cloud.managedkafka.schemaregistry.v1.ICreateSchemaRegistryRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'parent': request.parent ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('createSchemaRegistry request %j', request);
    const wrappedCallback: Callback<
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry,
        protos.google.cloud.managedkafka.schemaregistry.v1.ICreateSchemaRegistryRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('createSchemaRegistry response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.createSchemaRegistry(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry,
        protos.google.cloud.managedkafka.schemaregistry.v1.ICreateSchemaRegistryRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('createSchemaRegistry response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Delete a schema registry instance.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.name
 *   Required. The name of the schema registry instance to delete. Structured
 *   like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.protobuf.Empty|Empty}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.delete_schema_registry.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_DeleteSchemaRegistry_async
 */
  deleteSchemaRegistry(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaRegistryRequest,
      options?: CallOptions):
      Promise<[
        protos.google.protobuf.IEmpty,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaRegistryRequest|undefined, {}|undefined
      ]>;
  deleteSchemaRegistry(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaRegistryRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.protobuf.IEmpty,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaRegistryRequest|null|undefined,
          {}|null|undefined>): void;
  deleteSchemaRegistry(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaRegistryRequest,
      callback: Callback<
          protos.google.protobuf.IEmpty,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaRegistryRequest|null|undefined,
          {}|null|undefined>): void;
  deleteSchemaRegistry(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaRegistryRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.protobuf.IEmpty,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaRegistryRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.protobuf.IEmpty,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaRegistryRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.protobuf.IEmpty,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaRegistryRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'name': request.name ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('deleteSchemaRegistry request %j', request);
    const wrappedCallback: Callback<
        protos.google.protobuf.IEmpty,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaRegistryRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('deleteSchemaRegistry response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.deleteSchemaRegistry(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.protobuf.IEmpty,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaRegistryRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('deleteSchemaRegistry response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Get the context.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.name
 *   Required. The name of the context to return. Structured like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.cloud.managedkafka.schemaregistry.v1.Context|Context}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.get_context.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_GetContext_async
 */
  getContext(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IGetContextRequest,
      options?: CallOptions):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.IContext,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetContextRequest|undefined, {}|undefined
      ]>;
  getContext(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IGetContextRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.IContext,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetContextRequest|null|undefined,
          {}|null|undefined>): void;
  getContext(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IGetContextRequest,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.IContext,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetContextRequest|null|undefined,
          {}|null|undefined>): void;
  getContext(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IGetContextRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.IContext,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetContextRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.IContext,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetContextRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.IContext,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetContextRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'name': request.name ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('getContext request %j', request);
    const wrappedCallback: Callback<
        protos.google.cloud.managedkafka.schemaregistry.v1.IContext,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetContextRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('getContext response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.getContext(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.cloud.managedkafka.schemaregistry.v1.IContext,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetContextRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('getContext response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * List contexts for a schema registry.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.parent
 *   Required. The parent of the contexts. Structured like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.api.HttpBody|HttpBody}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.list_contexts.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_ListContexts_async
 */
  listContexts(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IListContextsRequest,
      options?: CallOptions):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListContextsRequest|undefined, {}|undefined
      ]>;
  listContexts(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IListContextsRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListContextsRequest|null|undefined,
          {}|null|undefined>): void;
  listContexts(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IListContextsRequest,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListContextsRequest|null|undefined,
          {}|null|undefined>): void;
  listContexts(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IListContextsRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListContextsRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListContextsRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListContextsRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'parent': request.parent ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('listContexts request %j', request);
    const wrappedCallback: Callback<
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListContextsRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('listContexts response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.listContexts(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListContextsRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('listContexts response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Get the schema for the given schema id.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.name
 *   Required. The name of the schema to return. Structured like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 * @param {string} [request.subject]
 *   Optional. Used to limit the search for the schema ID to a specific subject,
 *   otherwise the schema ID will be searched for in all subjects in the given
 *   specified context.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.cloud.managedkafka.schemaregistry.v1.Schema|Schema}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.get_schema.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_GetSchema_async
 */
  getSchema(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest,
      options?: CallOptions):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchema,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest|undefined, {}|undefined
      ]>;
  getSchema(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchema,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest|null|undefined,
          {}|null|undefined>): void;
  getSchema(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchema,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest|null|undefined,
          {}|null|undefined>): void;
  getSchema(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchema,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchema,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchema,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'name': request.name ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('getSchema request %j', request);
    const wrappedCallback: Callback<
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchema,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('getSchema response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.getSchema(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchema,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('getSchema response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Get the schema string for the given schema id.
 * The response will be the schema string.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.name
 *   Required. The name of the schema to return. Structured like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 * @param {string} [request.subject]
 *   Optional. Used to limit the search for the schema ID to a specific subject,
 *   otherwise the schema ID will be searched for in all subjects in the given
 *   specified context.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.api.HttpBody|HttpBody}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.get_raw_schema.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_GetRawSchema_async
 */
  getRawSchema(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest,
      options?: CallOptions):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest|undefined, {}|undefined
      ]>;
  getRawSchema(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest|null|undefined,
          {}|null|undefined>): void;
  getRawSchema(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest|null|undefined,
          {}|null|undefined>): void;
  getRawSchema(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'name': request.name ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('getRawSchema request %j', request);
    const wrappedCallback: Callback<
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('getRawSchema response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.getRawSchema(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('getRawSchema response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * List the schema versions for the given schema id.
 * The response will be an array of subject-version pairs as:
 * [{"subject":"subject1", "version":1}, {"subject":"subject2", "version":2}].
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.parent
 *   Required. The schema whose schema versions are to be listed. Structured
 *   like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 *   or
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
 * @param {string} [request.subject]
 *   Optional. The subject to filter the subjects by.
 * @param {boolean} [request.deleted]
 *   Optional. If true, the response will include soft-deleted versions of the
 *   schema, even if the subject is soft-deleted. The default is false.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.api.HttpBody|HttpBody}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.list_schema_versions.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_ListSchemaVersions_async
 */
  listSchemaVersions(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaVersionsRequest,
      options?: CallOptions):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaVersionsRequest|undefined, {}|undefined
      ]>;
  listSchemaVersions(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaVersionsRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaVersionsRequest|null|undefined,
          {}|null|undefined>): void;
  listSchemaVersions(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaVersionsRequest,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaVersionsRequest|null|undefined,
          {}|null|undefined>): void;
  listSchemaVersions(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaVersionsRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaVersionsRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaVersionsRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaVersionsRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'parent': request.parent ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('listSchemaVersions request %j', request);
    const wrappedCallback: Callback<
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaVersionsRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('listSchemaVersions response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.listSchemaVersions(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaVersionsRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('listSchemaVersions response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * List the supported schema types.
 * The response will be an array of schema types.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.parent
 *   Required. The parent schema registry whose schema types are to be listed.
 *   Structured like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.api.HttpBody|HttpBody}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.list_schema_types.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_ListSchemaTypes_async
 */
  listSchemaTypes(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaTypesRequest,
      options?: CallOptions):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaTypesRequest|undefined, {}|undefined
      ]>;
  listSchemaTypes(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaTypesRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaTypesRequest|null|undefined,
          {}|null|undefined>): void;
  listSchemaTypes(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaTypesRequest,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaTypesRequest|null|undefined,
          {}|null|undefined>): void;
  listSchemaTypes(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaTypesRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaTypesRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaTypesRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaTypesRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'parent': request.parent ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('listSchemaTypes request %j', request);
    const wrappedCallback: Callback<
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaTypesRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('listSchemaTypes response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.listSchemaTypes(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaTypesRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('listSchemaTypes response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * List subjects in the schema registry.
 * The response will be an array of subject names.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.parent
 *   Required. The parent schema registry/context whose subjects are to be
 *   listed. Structured like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
 *   or
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
 * @param {string} [request.subjectPrefix]
 *   Optional. The context to filter the subjects by, in the format of
 *   `:.{context}:`. If unset, all subjects in the registry are returned. Set to
 *   empty string or add as
 *   '?subjectPrefix=' at the end of this request to list subjects in the
 *   default context.
 * @param {boolean} [request.deleted]
 *   Optional. If true, the response will include soft-deleted subjects. The
 *   default is false.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.api.HttpBody|HttpBody}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.list_subjects.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_ListSubjects_async
 */
  listSubjects(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsRequest,
      options?: CallOptions):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsRequest|undefined, {}|undefined
      ]>;
  listSubjects(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsRequest|null|undefined,
          {}|null|undefined>): void;
  listSubjects(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsRequest,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsRequest|null|undefined,
          {}|null|undefined>): void;
  listSubjects(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'parent': request.parent ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('listSubjects request %j', request);
    const wrappedCallback: Callback<
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('listSubjects response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.listSubjects(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('listSubjects response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * List subjects which reference a particular schema id.
 * The response will be an array of subject names.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.parent
 *   Required. The schema resource whose associated subjects are to be listed.
 *   Structured like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
 *   or
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
 * @param {string} [request.subject]
 *   Optional. The subject to filter the subjects by.
 * @param {boolean} [request.deleted]
 *   Optional. If true, the response will include soft-deleted subjects. The
 *   default is false.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.api.HttpBody|HttpBody}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.list_subjects_by_schema_id.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_ListSubjectsBySchemaId_async
 */
  listSubjectsBySchemaId(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsBySchemaIdRequest,
      options?: CallOptions):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsBySchemaIdRequest|undefined, {}|undefined
      ]>;
  listSubjectsBySchemaId(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsBySchemaIdRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsBySchemaIdRequest|null|undefined,
          {}|null|undefined>): void;
  listSubjectsBySchemaId(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsBySchemaIdRequest,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsBySchemaIdRequest|null|undefined,
          {}|null|undefined>): void;
  listSubjectsBySchemaId(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsBySchemaIdRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsBySchemaIdRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsBySchemaIdRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsBySchemaIdRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'parent': request.parent ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('listSubjectsBySchemaId request %j', request);
    const wrappedCallback: Callback<
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsBySchemaIdRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('listSubjectsBySchemaId response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.listSubjectsBySchemaId(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListSubjectsBySchemaIdRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('listSubjectsBySchemaId response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Delete a subject.
 * The response will be an array of versions of the deleted subject.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.name
 *   Required. The name of the subject to delete. Structured like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *   or
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 * @param {boolean} [request.permanent]
 *   Optional. If true, the subject and all associated metadata including the
 *   schema ID will be deleted permanently. Otherwise, only the subject is
 *   soft-deleted. The default is false. Soft-deleted subjects can still be
 *   searched in ListSubjects API call with deleted=true query parameter. A
 *   soft-delete of a subject must be performed before a hard-delete.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.api.HttpBody|HttpBody}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.delete_subject.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_DeleteSubject_async
 */
  deleteSubject(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSubjectRequest,
      options?: CallOptions):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSubjectRequest|undefined, {}|undefined
      ]>;
  deleteSubject(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSubjectRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSubjectRequest|null|undefined,
          {}|null|undefined>): void;
  deleteSubject(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSubjectRequest,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSubjectRequest|null|undefined,
          {}|null|undefined>): void;
  deleteSubject(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSubjectRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSubjectRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSubjectRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSubjectRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'name': request.name ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('deleteSubject request %j', request);
    const wrappedCallback: Callback<
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSubjectRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('deleteSubject response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.deleteSubject(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSubjectRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('deleteSubject response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Lookup a schema under the specified subject.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.parent
 *   Required. The subject to lookup the schema in. Structured like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *   or
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 * @param {google.cloud.managedkafka.schemaregistry.v1.Schema.SchemaType} [request.schemaType]
 *   Optional. The schema type of the schema.
 * @param {string} request.schema
 *   Required. The schema payload
 * @param {number[]} [request.references]
 *   Optional. The schema references used by the schema.
 * @param {boolean} [request.normalize]
 *   Optional. If true, the schema will be normalized before being looked up.
 *   The default is false.
 * @param {boolean} [request.deleted]
 *   Optional. If true, soft-deleted versions will be included in lookup, no
 *   matter if the subject is active or soft-deleted. If false, soft-deleted
 *   versions will be excluded. The default is false.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.cloud.managedkafka.schemaregistry.v1.SchemaVersion|SchemaVersion}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.lookup_version.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_LookupVersion_async
 */
  lookupVersion(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.ILookupVersionRequest,
      options?: CallOptions):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion,
        protos.google.cloud.managedkafka.schemaregistry.v1.ILookupVersionRequest|undefined, {}|undefined
      ]>;
  lookupVersion(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.ILookupVersionRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion,
          protos.google.cloud.managedkafka.schemaregistry.v1.ILookupVersionRequest|null|undefined,
          {}|null|undefined>): void;
  lookupVersion(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.ILookupVersionRequest,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion,
          protos.google.cloud.managedkafka.schemaregistry.v1.ILookupVersionRequest|null|undefined,
          {}|null|undefined>): void;
  lookupVersion(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.ILookupVersionRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion,
          protos.google.cloud.managedkafka.schemaregistry.v1.ILookupVersionRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion,
          protos.google.cloud.managedkafka.schemaregistry.v1.ILookupVersionRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion,
        protos.google.cloud.managedkafka.schemaregistry.v1.ILookupVersionRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'parent': request.parent ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('lookupVersion request %j', request);
    const wrappedCallback: Callback<
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion,
        protos.google.cloud.managedkafka.schemaregistry.v1.ILookupVersionRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('lookupVersion response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.lookupVersion(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion,
        protos.google.cloud.managedkafka.schemaregistry.v1.ILookupVersionRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('lookupVersion response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Get a versioned schema (schema with subject/version) of a subject.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.name
 *   Required. The name of the subject to return versions. Structured like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *   or
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 * @param {boolean} [request.deleted]
 *   Optional. If true, no matter if the subject/version is soft-deleted or not,
 *   it returns the version details. If false, it returns NOT_FOUND error if the
 *   subject/version is soft-deleted. The default is false.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.cloud.managedkafka.schemaregistry.v1.SchemaVersion|SchemaVersion}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.get_version.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_GetVersion_async
 */
  getVersion(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest,
      options?: CallOptions):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest|undefined, {}|undefined
      ]>;
  getVersion(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest|null|undefined,
          {}|null|undefined>): void;
  getVersion(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest|null|undefined,
          {}|null|undefined>): void;
  getVersion(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'name': request.name ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('getVersion request %j', request);
    const wrappedCallback: Callback<
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('getVersion response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.getVersion(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('getVersion response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Get the schema string only for a version of a subject.
 * The response will be the schema string.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.name
 *   Required. The name of the subject to return versions. Structured like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *   or
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 * @param {boolean} [request.deleted]
 *   Optional. If true, no matter if the subject/version is soft-deleted or not,
 *   it returns the version details. If false, it returns NOT_FOUND error if the
 *   subject/version is soft-deleted. The default is false.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.api.HttpBody|HttpBody}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.get_raw_schema_version.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_GetRawSchemaVersion_async
 */
  getRawSchemaVersion(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest,
      options?: CallOptions):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest|undefined, {}|undefined
      ]>;
  getRawSchemaVersion(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest|null|undefined,
          {}|null|undefined>): void;
  getRawSchemaVersion(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest|null|undefined,
          {}|null|undefined>): void;
  getRawSchemaVersion(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'name': request.name ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('getRawSchemaVersion request %j', request);
    const wrappedCallback: Callback<
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('getRawSchemaVersion response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.getRawSchemaVersion(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetVersionRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('getRawSchemaVersion response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Get all versions of a subject.
 * The response will be an array of versions of the subject.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.parent
 *   Required. The subject whose versions are to be listed. Structured like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *   or
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 * @param {boolean} [request.deleted]
 *   Optional. If true, the response will include soft-deleted versions of an
 *   active or soft-deleted subject. The default is false.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.api.HttpBody|HttpBody}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.list_versions.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_ListVersions_async
 */
  listVersions(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IListVersionsRequest,
      options?: CallOptions):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListVersionsRequest|undefined, {}|undefined
      ]>;
  listVersions(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IListVersionsRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListVersionsRequest|null|undefined,
          {}|null|undefined>): void;
  listVersions(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IListVersionsRequest,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListVersionsRequest|null|undefined,
          {}|null|undefined>): void;
  listVersions(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IListVersionsRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListVersionsRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListVersionsRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListVersionsRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'parent': request.parent ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('listVersions request %j', request);
    const wrappedCallback: Callback<
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListVersionsRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('listVersions response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.listVersions(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListVersionsRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('listVersions response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Register a new version under a given subject with the given schema.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.parent
 *   Required. The subject to create the version for. Structured like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
 *   or
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
 * @param {number} [request.version]
 *   Optional. The version to create. It is optional. If not specified, the
 *   version will be created with the max version ID of the subject increased
 *   by 1. If the version ID is specified, it will be used as the new version ID
 *   and must not be used by an existing version of the subject.
 * @param {number} [request.id]
 *   Optional. The schema ID of the schema. If not specified, the schema ID will
 *   be generated by the server. If the schema ID is specified, it must not be
 *   used by an existing schema that is different from the schema to be created.
 * @param {google.cloud.managedkafka.schemaregistry.v1.Schema.SchemaType} [request.schemaType]
 *   Optional. The type of the schema. It is optional. If not specified, the
 *   schema type will be AVRO.
 * @param {string} request.schema
 *   Required. The schema payload
 * @param {number[]} [request.references]
 *   Optional. The schema references used by the schema.
 * @param {boolean} [request.normalize]
 *   Optional. If true, the schema will be normalized before being stored. The
 *   default is false.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.cloud.managedkafka.schemaregistry.v1.CreateVersionResponse|CreateVersionResponse}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.create_version.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_CreateVersion_async
 */
  createVersion(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionRequest,
      options?: CallOptions):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionResponse,
        protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionRequest|undefined, {}|undefined
      ]>;
  createVersion(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionResponse,
          protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionRequest|null|undefined,
          {}|null|undefined>): void;
  createVersion(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionRequest,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionResponse,
          protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionRequest|null|undefined,
          {}|null|undefined>): void;
  createVersion(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionResponse,
          protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionResponse,
          protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionResponse,
        protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'parent': request.parent ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('createVersion request %j', request);
    const wrappedCallback: Callback<
        protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionResponse,
        protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('createVersion response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.createVersion(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionResponse,
        protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('createVersion response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Delete a version of a subject.
 * The response will be the deleted version id.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.name
 *   Required. The name of the subject version to delete. Structured like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *   or
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 * @param {boolean} [request.permanent]
 *   Optional. If true, both the version and the referenced schema ID will be
 *   permanently deleted. The default is false. If false, the version will be
 *   deleted but the schema ID will be retained. Soft-deleted versions can still
 *   be searched in ListVersions API call with deleted=true query parameter. A
 *   soft-delete of a version must be performed before a hard-delete.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.api.HttpBody|HttpBody}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.delete_version.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_DeleteVersion_async
 */
  deleteVersion(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteVersionRequest,
      options?: CallOptions):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteVersionRequest|undefined, {}|undefined
      ]>;
  deleteVersion(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteVersionRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteVersionRequest|null|undefined,
          {}|null|undefined>): void;
  deleteVersion(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteVersionRequest,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteVersionRequest|null|undefined,
          {}|null|undefined>): void;
  deleteVersion(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteVersionRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteVersionRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteVersionRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteVersionRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'name': request.name ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('deleteVersion request %j', request);
    const wrappedCallback: Callback<
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteVersionRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('deleteVersion response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.deleteVersion(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteVersionRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('deleteVersion response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Get a list of IDs of schemas that reference the schema with the given
 * subject and version.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.parent
 *   Required. The version to list referenced by. Structured like:
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
 *   or
 *   `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.api.HttpBody|HttpBody}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.list_referenced_schemas.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_ListReferencedSchemas_async
 */
  listReferencedSchemas(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IListReferencedSchemasRequest,
      options?: CallOptions):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListReferencedSchemasRequest|undefined, {}|undefined
      ]>;
  listReferencedSchemas(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IListReferencedSchemasRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListReferencedSchemasRequest|null|undefined,
          {}|null|undefined>): void;
  listReferencedSchemas(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IListReferencedSchemasRequest,
      callback: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListReferencedSchemasRequest|null|undefined,
          {}|null|undefined>): void;
  listReferencedSchemas(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IListReferencedSchemasRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListReferencedSchemasRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.api.IHttpBody,
          protos.google.cloud.managedkafka.schemaregistry.v1.IListReferencedSchemasRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListReferencedSchemasRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'parent': request.parent ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('listReferencedSchemas request %j', request);
    const wrappedCallback: Callback<
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListReferencedSchemasRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('listReferencedSchemas response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.listReferencedSchemas(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.api.IHttpBody,
        protos.google.cloud.managedkafka.schemaregistry.v1.IListReferencedSchemasRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('listReferencedSchemas response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Check compatibility of a schema with all versions or a specific version of
 * a subject.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.name
 *   Required. The name of the resource to check compatibility for. The format
 *   is either of following:
 *   * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/* /versions: Check compatibility with one or
 *     more versions of the specified subject.
 *   * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/{subject}/versions/{version}: Check
 *     compatibility with a specific version of the subject.
 * @param {google.cloud.managedkafka.schemaregistry.v1.Schema.SchemaType} [request.schemaType]
 *   Optional. The schema type of the schema.
 * @param {string} request.schema
 *   Required. The schema payload
 * @param {number[]} [request.references]
 *   Optional. The schema references used by the schema.
 * @param {boolean} [request.verbose]
 *   Optional. If true, the response will contain the compatibility check result
 *   with reasons for failed checks. The default is false.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.cloud.managedkafka.schemaregistry.v1.CheckCompatibilityResponse|CheckCompatibilityResponse}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.check_compatibility.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_CheckCompatibility_async
 */
  checkCompatibility(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityRequest,
      options?: CallOptions):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityResponse,
        protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityRequest|undefined, {}|undefined
      ]>;
  checkCompatibility(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityResponse,
          protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityRequest|null|undefined,
          {}|null|undefined>): void;
  checkCompatibility(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityRequest,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityResponse,
          protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityRequest|null|undefined,
          {}|null|undefined>): void;
  checkCompatibility(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityResponse,
          protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityResponse,
          protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityResponse,
        protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'name': request.name ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('checkCompatibility request %j', request);
    const wrappedCallback: Callback<
        protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityResponse,
        protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('checkCompatibility response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.checkCompatibility(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityResponse,
        protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('checkCompatibility response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Get schema config at global level or for a subject.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.name
 *   Required. The resource name to get the config for. It can be either of
 *   following:
 *     * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Get config at global level.
 *     * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}: Get config for a specific subject.
 * @param {boolean} [request.defaultToGlobal]
 *   Optional. If true, the config will fall back to the config at the global
 *   level if no subject level config is found.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.cloud.managedkafka.schemaregistry.v1.SchemaConfig|SchemaConfig}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.get_schema_config.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_GetSchemaConfig_async
 */
  getSchemaConfig(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaConfigRequest,
      options?: CallOptions):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaConfigRequest|undefined, {}|undefined
      ]>;
  getSchemaConfig(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaConfigRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaConfigRequest|null|undefined,
          {}|null|undefined>): void;
  getSchemaConfig(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaConfigRequest,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaConfigRequest|null|undefined,
          {}|null|undefined>): void;
  getSchemaConfig(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaConfigRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaConfigRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaConfigRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaConfigRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'name': request.name ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('getSchemaConfig request %j', request);
    const wrappedCallback: Callback<
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaConfigRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('getSchemaConfig response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.getSchemaConfig(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaConfigRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('getSchemaConfig response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Update config at global level or for a subject.
 * Creates a SchemaSubject-level SchemaConfig if it does not exist.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.name
 *   Required. The resource name to update the config for. It can be either of
 *   following:
 *     * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Update config at global level.
 *     * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}: Update config for a specific subject.
 * @param {google.cloud.managedkafka.schemaregistry.v1.SchemaConfig.CompatibilityType} request.compatibility
 *   Required. The compatibility type of the schemas.
 *   Cannot be unset for a SchemaRegistry-level SchemaConfig.
 *   If unset on a SchemaSubject-level SchemaConfig, removes the compatibility
 *   field for the SchemaConfig.
 * @param {boolean} [request.normalize]
 *   Optional. If true, the schema will be normalized before being stored or
 *   looked up. The default is false. Cannot be unset for a SchemaRegistry-level
 *   SchemaConfig. If unset on a SchemaSubject-level SchemaConfig, removes the
 *   normalize field for the SchemaConfig.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.cloud.managedkafka.schemaregistry.v1.SchemaConfig|SchemaConfig}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.update_schema_config.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_UpdateSchemaConfig_async
 */
  updateSchemaConfig(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaConfigRequest,
      options?: CallOptions):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
        protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaConfigRequest|undefined, {}|undefined
      ]>;
  updateSchemaConfig(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaConfigRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
          protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaConfigRequest|null|undefined,
          {}|null|undefined>): void;
  updateSchemaConfig(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaConfigRequest,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
          protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaConfigRequest|null|undefined,
          {}|null|undefined>): void;
  updateSchemaConfig(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaConfigRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
          protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaConfigRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
          protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaConfigRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
        protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaConfigRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'name': request.name ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('updateSchemaConfig request %j', request);
    const wrappedCallback: Callback<
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
        protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaConfigRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('updateSchemaConfig response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.updateSchemaConfig(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
        protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaConfigRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('updateSchemaConfig response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Delete schema config for a subject.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.name
 *   Required. The resource name of subject to delete the config for. The format
 *   is
 *     * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.cloud.managedkafka.schemaregistry.v1.SchemaConfig|SchemaConfig}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.delete_schema_config.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_DeleteSchemaConfig_async
 */
  deleteSchemaConfig(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaConfigRequest,
      options?: CallOptions):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaConfigRequest|undefined, {}|undefined
      ]>;
  deleteSchemaConfig(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaConfigRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaConfigRequest|null|undefined,
          {}|null|undefined>): void;
  deleteSchemaConfig(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaConfigRequest,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaConfigRequest|null|undefined,
          {}|null|undefined>): void;
  deleteSchemaConfig(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaConfigRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaConfigRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaConfigRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaConfigRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'name': request.name ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('deleteSchemaConfig request %j', request);
    const wrappedCallback: Callback<
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaConfigRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('deleteSchemaConfig response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.deleteSchemaConfig(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaConfigRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('deleteSchemaConfig response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Get mode at global level or for a subject.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.name
 *   Required. The resource name of the mode. The format is
 *     * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for a schema registry, or
 *     * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}: mode for a specific subject in a specific context
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.cloud.managedkafka.schemaregistry.v1.SchemaMode|SchemaMode}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.get_schema_mode.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_GetSchemaMode_async
 */
  getSchemaMode(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaModeRequest,
      options?: CallOptions):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaModeRequest|undefined, {}|undefined
      ]>;
  getSchemaMode(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaModeRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaModeRequest|null|undefined,
          {}|null|undefined>): void;
  getSchemaMode(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaModeRequest,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaModeRequest|null|undefined,
          {}|null|undefined>): void;
  getSchemaMode(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaModeRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaModeRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
          protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaModeRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaModeRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'name': request.name ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('getSchemaMode request %j', request);
    const wrappedCallback: Callback<
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaModeRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('getSchemaMode response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.getSchemaMode(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
        protos.google.cloud.managedkafka.schemaregistry.v1.IGetSchemaModeRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('getSchemaMode response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Update mode at global level or for a subject.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.name
 *   Required. The resource name of the mode. The format is
 *     * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for a schema registry, or
 *     * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}: mode for a specific subject in a specific context
 * @param {google.cloud.managedkafka.schemaregistry.v1.SchemaMode.ModeType} request.mode
 *   Required. The mode type.
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.cloud.managedkafka.schemaregistry.v1.SchemaMode|SchemaMode}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.update_schema_mode.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_UpdateSchemaMode_async
 */
  updateSchemaMode(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaModeRequest,
      options?: CallOptions):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
        protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaModeRequest|undefined, {}|undefined
      ]>;
  updateSchemaMode(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaModeRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
          protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaModeRequest|null|undefined,
          {}|null|undefined>): void;
  updateSchemaMode(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaModeRequest,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
          protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaModeRequest|null|undefined,
          {}|null|undefined>): void;
  updateSchemaMode(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaModeRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
          protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaModeRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
          protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaModeRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
        protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaModeRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'name': request.name ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('updateSchemaMode request %j', request);
    const wrappedCallback: Callback<
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
        protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaModeRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('updateSchemaMode response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.updateSchemaMode(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
        protos.google.cloud.managedkafka.schemaregistry.v1.IUpdateSchemaModeRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('updateSchemaMode response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }
/**
 * Delete schema mode for a subject.
 *
 * @param {Object} request
 *   The request object that will be sent.
 * @param {string} request.name
 *   Required. The resource name of subject to delete the mode for. The format
 *   is
 *     * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}
 *     * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}
 * @param {object} [options]
 *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
 * @returns {Promise} - The promise which resolves to an array.
 *   The first element of the array is an object representing {@link protos.google.cloud.managedkafka.schemaregistry.v1.SchemaMode|SchemaMode}.
 *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
 *   for more details and examples.
 * @example <caption>include:samples/generated/v1/managed_schema_registry.delete_schema_mode.js</caption>
 * region_tag:managedkafka_v1_generated_ManagedSchemaRegistry_DeleteSchemaMode_async
 */
  deleteSchemaMode(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaModeRequest,
      options?: CallOptions):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaModeRequest|undefined, {}|undefined
      ]>;
  deleteSchemaMode(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaModeRequest,
      options: CallOptions,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaModeRequest|null|undefined,
          {}|null|undefined>): void;
  deleteSchemaMode(
      request: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaModeRequest,
      callback: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaModeRequest|null|undefined,
          {}|null|undefined>): void;
  deleteSchemaMode(
      request?: protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaModeRequest,
      optionsOrCallback?: CallOptions|Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaModeRequest|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
          protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaModeRequest|null|undefined,
          {}|null|undefined>):
      Promise<[
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaModeRequest|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers[
      'x-goog-request-params'
    ] = this._gaxModule.routingHeader.fromParams({
      'name': request.name ?? '',
    });
    this.initialize().catch(err => {throw err});
    this._log.info('deleteSchemaMode request %j', request);
    const wrappedCallback: Callback<
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaModeRequest|null|undefined,
        {}|null|undefined>|undefined = callback
      ? (error, response, options, rawResponse) => {
          this._log.info('deleteSchemaMode response %j', response);
          callback!(error, response, options, rawResponse); // We verified callback above.
        }
      : undefined;
    return this.innerApiCalls.deleteSchemaMode(request, options, wrappedCallback)
      ?.then(([response, options, rawResponse]: [
        protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode,
        protos.google.cloud.managedkafka.schemaregistry.v1.IDeleteSchemaModeRequest|undefined,
        {}|undefined
      ]) => {
        this._log.info('deleteSchemaMode response %j', response);
        return [response, options, rawResponse];
      }).catch((error: any) => {
        if (error && 'statusDetails' in error && error.statusDetails instanceof Array) {
          const protos = this._gaxModule.protobuf.Root.fromJSON(jsonProtos) as unknown as gax.protobuf.Type;
          error.statusDetails = decodeAnyProtosInArray(error.statusDetails, protos);
        }
        throw error;
      });
  }

/**
   * Gets information about a location.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.name
   *   Resource name for the location.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html | CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing {@link google.cloud.location.Location | Location}.
   *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }
   *   for more details and examples.
   * @example
   * ```
   * const [response] = await client.getLocation(request);
   * ```
   */
  getLocation(
    request: LocationProtos.google.cloud.location.IGetLocationRequest,
    options?:
      | gax.CallOptions
      | Callback<
          LocationProtos.google.cloud.location.ILocation,
          | LocationProtos.google.cloud.location.IGetLocationRequest
          | null
          | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      LocationProtos.google.cloud.location.ILocation,
      | LocationProtos.google.cloud.location.IGetLocationRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): Promise<LocationProtos.google.cloud.location.ILocation> {
    return this.locationsClient.getLocation(request, options, callback);
  }

/**
   * Lists information about the supported locations for this service. Returns an iterable object.
   *
   * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.name
   *   The resource that owns the locations collection, if applicable.
   * @param {string} request.filter
   *   The standard list filter.
   * @param {number} request.pageSize
   *   The standard list page size.
   * @param {string} request.pageToken
   *   The standard list page token.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Object}
   *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
   *   When you iterate the returned iterable, each element will be an object representing
   *   {@link google.cloud.location.Location | Location}. The API will be called under the hood as needed, once per the page,
   *   so you can stop the iteration when you don't need more results.
   *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
   *   for more details and examples.
   * @example
   * ```
   * const iterable = client.listLocationsAsync(request);
   * for await (const response of iterable) {
   *   // process response
   * }
   * ```
   */
  listLocationsAsync(
    request: LocationProtos.google.cloud.location.IListLocationsRequest,
    options?: CallOptions
  ): AsyncIterable<LocationProtos.google.cloud.location.ILocation> {
    return this.locationsClient.listLocationsAsync(request, options);
  }

  // --------------------
  // -- Path templates --
  // --------------------

  /**
   * Return a fully-qualified projectLocationSchemaRegistryCompatibilitySubjectVersions resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} schema_registry
   * @param {string} subject
   * @param {string} version
   * @returns {string} Resource name string.
   */
  projectLocationSchemaRegistryCompatibilitySubjectVersionsPath(project:string,location:string,schemaRegistry:string,subject:string,version:string) {
    return this.pathTemplates.projectLocationSchemaRegistryCompatibilitySubjectVersionsPathTemplate.render({
      project: project,
      location: location,
      schema_registry: schemaRegistry,
      subject: subject,
      version: version,
    });
  }

  /**
   * Parse the project from ProjectLocationSchemaRegistryCompatibilitySubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryCompatibilitySubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_compatibility_subject_versions resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromProjectLocationSchemaRegistryCompatibilitySubjectVersionsName(projectLocationSchemaRegistryCompatibilitySubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryCompatibilitySubjectVersionsPathTemplate.match(projectLocationSchemaRegistryCompatibilitySubjectVersionsName).project;
  }

  /**
   * Parse the location from ProjectLocationSchemaRegistryCompatibilitySubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryCompatibilitySubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_compatibility_subject_versions resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromProjectLocationSchemaRegistryCompatibilitySubjectVersionsName(projectLocationSchemaRegistryCompatibilitySubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryCompatibilitySubjectVersionsPathTemplate.match(projectLocationSchemaRegistryCompatibilitySubjectVersionsName).location;
  }

  /**
   * Parse the schema_registry from ProjectLocationSchemaRegistryCompatibilitySubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryCompatibilitySubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_compatibility_subject_versions resource.
   * @returns {string} A string representing the schema_registry.
   */
  matchSchemaRegistryFromProjectLocationSchemaRegistryCompatibilitySubjectVersionsName(projectLocationSchemaRegistryCompatibilitySubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryCompatibilitySubjectVersionsPathTemplate.match(projectLocationSchemaRegistryCompatibilitySubjectVersionsName).schema_registry;
  }

  /**
   * Parse the subject from ProjectLocationSchemaRegistryCompatibilitySubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryCompatibilitySubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_compatibility_subject_versions resource.
   * @returns {string} A string representing the subject.
   */
  matchSubjectFromProjectLocationSchemaRegistryCompatibilitySubjectVersionsName(projectLocationSchemaRegistryCompatibilitySubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryCompatibilitySubjectVersionsPathTemplate.match(projectLocationSchemaRegistryCompatibilitySubjectVersionsName).subject;
  }

  /**
   * Parse the version from ProjectLocationSchemaRegistryCompatibilitySubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryCompatibilitySubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_compatibility_subject_versions resource.
   * @returns {string} A string representing the version.
   */
  matchVersionFromProjectLocationSchemaRegistryCompatibilitySubjectVersionsName(projectLocationSchemaRegistryCompatibilitySubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryCompatibilitySubjectVersionsPathTemplate.match(projectLocationSchemaRegistryCompatibilitySubjectVersionsName).version;
  }

  /**
   * Return a fully-qualified projectLocationSchemaRegistryConfig resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} schema_registry
   * @returns {string} Resource name string.
   */
  projectLocationSchemaRegistryConfigPath(project:string,location:string,schemaRegistry:string) {
    return this.pathTemplates.projectLocationSchemaRegistryConfigPathTemplate.render({
      project: project,
      location: location,
      schema_registry: schemaRegistry,
    });
  }

  /**
   * Parse the project from ProjectLocationSchemaRegistryConfig resource.
   *
   * @param {string} projectLocationSchemaRegistryConfigName
   *   A fully-qualified path representing project_location_schema_registry_config resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromProjectLocationSchemaRegistryConfigName(projectLocationSchemaRegistryConfigName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryConfigPathTemplate.match(projectLocationSchemaRegistryConfigName).project;
  }

  /**
   * Parse the location from ProjectLocationSchemaRegistryConfig resource.
   *
   * @param {string} projectLocationSchemaRegistryConfigName
   *   A fully-qualified path representing project_location_schema_registry_config resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromProjectLocationSchemaRegistryConfigName(projectLocationSchemaRegistryConfigName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryConfigPathTemplate.match(projectLocationSchemaRegistryConfigName).location;
  }

  /**
   * Parse the schema_registry from ProjectLocationSchemaRegistryConfig resource.
   *
   * @param {string} projectLocationSchemaRegistryConfigName
   *   A fully-qualified path representing project_location_schema_registry_config resource.
   * @returns {string} A string representing the schema_registry.
   */
  matchSchemaRegistryFromProjectLocationSchemaRegistryConfigName(projectLocationSchemaRegistryConfigName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryConfigPathTemplate.match(projectLocationSchemaRegistryConfigName).schema_registry;
  }

  /**
   * Return a fully-qualified projectLocationSchemaRegistryContextCompatibilitySubjectVersions resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} schema_registry
   * @param {string} context
   * @param {string} subject
   * @param {string} version
   * @returns {string} Resource name string.
   */
  projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPath(project:string,location:string,schemaRegistry:string,context:string,subject:string,version:string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate.render({
      project: project,
      location: location,
      schema_registry: schemaRegistry,
      context: context,
      subject: subject,
      version: version,
    });
  }

  /**
   * Parse the project from ProjectLocationSchemaRegistryContextCompatibilitySubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_context_compatibility_subject_versions resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName(projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate.match(projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName).project;
  }

  /**
   * Parse the location from ProjectLocationSchemaRegistryContextCompatibilitySubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_context_compatibility_subject_versions resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName(projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate.match(projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName).location;
  }

  /**
   * Parse the schema_registry from ProjectLocationSchemaRegistryContextCompatibilitySubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_context_compatibility_subject_versions resource.
   * @returns {string} A string representing the schema_registry.
   */
  matchSchemaRegistryFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName(projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate.match(projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName).schema_registry;
  }

  /**
   * Parse the context from ProjectLocationSchemaRegistryContextCompatibilitySubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_context_compatibility_subject_versions resource.
   * @returns {string} A string representing the context.
   */
  matchContextFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName(projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate.match(projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName).context;
  }

  /**
   * Parse the subject from ProjectLocationSchemaRegistryContextCompatibilitySubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_context_compatibility_subject_versions resource.
   * @returns {string} A string representing the subject.
   */
  matchSubjectFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName(projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate.match(projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName).subject;
  }

  /**
   * Parse the version from ProjectLocationSchemaRegistryContextCompatibilitySubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_context_compatibility_subject_versions resource.
   * @returns {string} A string representing the version.
   */
  matchVersionFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName(projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate.match(projectLocationSchemaRegistryContextCompatibilitySubjectVersionsName).version;
  }

  /**
   * Return a fully-qualified projectLocationSchemaRegistryContextConfig resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} schema_registry
   * @param {string} context
   * @returns {string} Resource name string.
   */
  projectLocationSchemaRegistryContextConfigPath(project:string,location:string,schemaRegistry:string,context:string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextConfigPathTemplate.render({
      project: project,
      location: location,
      schema_registry: schemaRegistry,
      context: context,
    });
  }

  /**
   * Parse the project from ProjectLocationSchemaRegistryContextConfig resource.
   *
   * @param {string} projectLocationSchemaRegistryContextConfigName
   *   A fully-qualified path representing project_location_schema_registry_context_config resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromProjectLocationSchemaRegistryContextConfigName(projectLocationSchemaRegistryContextConfigName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextConfigPathTemplate.match(projectLocationSchemaRegistryContextConfigName).project;
  }

  /**
   * Parse the location from ProjectLocationSchemaRegistryContextConfig resource.
   *
   * @param {string} projectLocationSchemaRegistryContextConfigName
   *   A fully-qualified path representing project_location_schema_registry_context_config resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromProjectLocationSchemaRegistryContextConfigName(projectLocationSchemaRegistryContextConfigName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextConfigPathTemplate.match(projectLocationSchemaRegistryContextConfigName).location;
  }

  /**
   * Parse the schema_registry from ProjectLocationSchemaRegistryContextConfig resource.
   *
   * @param {string} projectLocationSchemaRegistryContextConfigName
   *   A fully-qualified path representing project_location_schema_registry_context_config resource.
   * @returns {string} A string representing the schema_registry.
   */
  matchSchemaRegistryFromProjectLocationSchemaRegistryContextConfigName(projectLocationSchemaRegistryContextConfigName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextConfigPathTemplate.match(projectLocationSchemaRegistryContextConfigName).schema_registry;
  }

  /**
   * Parse the context from ProjectLocationSchemaRegistryContextConfig resource.
   *
   * @param {string} projectLocationSchemaRegistryContextConfigName
   *   A fully-qualified path representing project_location_schema_registry_context_config resource.
   * @returns {string} A string representing the context.
   */
  matchContextFromProjectLocationSchemaRegistryContextConfigName(projectLocationSchemaRegistryContextConfigName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextConfigPathTemplate.match(projectLocationSchemaRegistryContextConfigName).context;
  }

  /**
   * Return a fully-qualified projectLocationSchemaRegistryContextMode resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} schema_registry
   * @param {string} context
   * @returns {string} Resource name string.
   */
  projectLocationSchemaRegistryContextModePath(project:string,location:string,schemaRegistry:string,context:string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextModePathTemplate.render({
      project: project,
      location: location,
      schema_registry: schemaRegistry,
      context: context,
    });
  }

  /**
   * Parse the project from ProjectLocationSchemaRegistryContextMode resource.
   *
   * @param {string} projectLocationSchemaRegistryContextModeName
   *   A fully-qualified path representing project_location_schema_registry_context_mode resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromProjectLocationSchemaRegistryContextModeName(projectLocationSchemaRegistryContextModeName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextModePathTemplate.match(projectLocationSchemaRegistryContextModeName).project;
  }

  /**
   * Parse the location from ProjectLocationSchemaRegistryContextMode resource.
   *
   * @param {string} projectLocationSchemaRegistryContextModeName
   *   A fully-qualified path representing project_location_schema_registry_context_mode resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromProjectLocationSchemaRegistryContextModeName(projectLocationSchemaRegistryContextModeName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextModePathTemplate.match(projectLocationSchemaRegistryContextModeName).location;
  }

  /**
   * Parse the schema_registry from ProjectLocationSchemaRegistryContextMode resource.
   *
   * @param {string} projectLocationSchemaRegistryContextModeName
   *   A fully-qualified path representing project_location_schema_registry_context_mode resource.
   * @returns {string} A string representing the schema_registry.
   */
  matchSchemaRegistryFromProjectLocationSchemaRegistryContextModeName(projectLocationSchemaRegistryContextModeName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextModePathTemplate.match(projectLocationSchemaRegistryContextModeName).schema_registry;
  }

  /**
   * Parse the context from ProjectLocationSchemaRegistryContextMode resource.
   *
   * @param {string} projectLocationSchemaRegistryContextModeName
   *   A fully-qualified path representing project_location_schema_registry_context_mode resource.
   * @returns {string} A string representing the context.
   */
  matchContextFromProjectLocationSchemaRegistryContextModeName(projectLocationSchemaRegistryContextModeName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextModePathTemplate.match(projectLocationSchemaRegistryContextModeName).context;
  }

  /**
   * Return a fully-qualified projectLocationSchemaRegistryContextSchemas resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} schema_registry
   * @param {string} context
   * @param {string} schema
   * @returns {string} Resource name string.
   */
  projectLocationSchemaRegistryContextSchemasPath(project:string,location:string,schemaRegistry:string,context:string,schema:string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSchemasPathTemplate.render({
      project: project,
      location: location,
      schema_registry: schemaRegistry,
      context: context,
      schema: schema,
    });
  }

  /**
   * Parse the project from ProjectLocationSchemaRegistryContextSchemas resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSchemasName
   *   A fully-qualified path representing project_location_schema_registry_context_schemas resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromProjectLocationSchemaRegistryContextSchemasName(projectLocationSchemaRegistryContextSchemasName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSchemasPathTemplate.match(projectLocationSchemaRegistryContextSchemasName).project;
  }

  /**
   * Parse the location from ProjectLocationSchemaRegistryContextSchemas resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSchemasName
   *   A fully-qualified path representing project_location_schema_registry_context_schemas resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromProjectLocationSchemaRegistryContextSchemasName(projectLocationSchemaRegistryContextSchemasName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSchemasPathTemplate.match(projectLocationSchemaRegistryContextSchemasName).location;
  }

  /**
   * Parse the schema_registry from ProjectLocationSchemaRegistryContextSchemas resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSchemasName
   *   A fully-qualified path representing project_location_schema_registry_context_schemas resource.
   * @returns {string} A string representing the schema_registry.
   */
  matchSchemaRegistryFromProjectLocationSchemaRegistryContextSchemasName(projectLocationSchemaRegistryContextSchemasName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSchemasPathTemplate.match(projectLocationSchemaRegistryContextSchemasName).schema_registry;
  }

  /**
   * Parse the context from ProjectLocationSchemaRegistryContextSchemas resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSchemasName
   *   A fully-qualified path representing project_location_schema_registry_context_schemas resource.
   * @returns {string} A string representing the context.
   */
  matchContextFromProjectLocationSchemaRegistryContextSchemasName(projectLocationSchemaRegistryContextSchemasName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSchemasPathTemplate.match(projectLocationSchemaRegistryContextSchemasName).context;
  }

  /**
   * Parse the schema from ProjectLocationSchemaRegistryContextSchemas resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSchemasName
   *   A fully-qualified path representing project_location_schema_registry_context_schemas resource.
   * @returns {string} A string representing the schema.
   */
  matchSchemaFromProjectLocationSchemaRegistryContextSchemasName(projectLocationSchemaRegistryContextSchemasName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSchemasPathTemplate.match(projectLocationSchemaRegistryContextSchemasName).schema;
  }

  /**
   * Return a fully-qualified projectLocationSchemaRegistryContextSubject resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} schema_registry
   * @param {string} context
   * @param {string} subject
   * @returns {string} Resource name string.
   */
  projectLocationSchemaRegistryContextSubjectPath(project:string,location:string,schemaRegistry:string,context:string,subject:string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectPathTemplate.render({
      project: project,
      location: location,
      schema_registry: schemaRegistry,
      context: context,
      subject: subject,
    });
  }

  /**
   * Parse the project from ProjectLocationSchemaRegistryContextSubject resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSubjectName
   *   A fully-qualified path representing project_location_schema_registry_context_subject resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromProjectLocationSchemaRegistryContextSubjectName(projectLocationSchemaRegistryContextSubjectName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectPathTemplate.match(projectLocationSchemaRegistryContextSubjectName).project;
  }

  /**
   * Parse the location from ProjectLocationSchemaRegistryContextSubject resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSubjectName
   *   A fully-qualified path representing project_location_schema_registry_context_subject resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromProjectLocationSchemaRegistryContextSubjectName(projectLocationSchemaRegistryContextSubjectName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectPathTemplate.match(projectLocationSchemaRegistryContextSubjectName).location;
  }

  /**
   * Parse the schema_registry from ProjectLocationSchemaRegistryContextSubject resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSubjectName
   *   A fully-qualified path representing project_location_schema_registry_context_subject resource.
   * @returns {string} A string representing the schema_registry.
   */
  matchSchemaRegistryFromProjectLocationSchemaRegistryContextSubjectName(projectLocationSchemaRegistryContextSubjectName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectPathTemplate.match(projectLocationSchemaRegistryContextSubjectName).schema_registry;
  }

  /**
   * Parse the context from ProjectLocationSchemaRegistryContextSubject resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSubjectName
   *   A fully-qualified path representing project_location_schema_registry_context_subject resource.
   * @returns {string} A string representing the context.
   */
  matchContextFromProjectLocationSchemaRegistryContextSubjectName(projectLocationSchemaRegistryContextSubjectName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectPathTemplate.match(projectLocationSchemaRegistryContextSubjectName).context;
  }

  /**
   * Parse the subject from ProjectLocationSchemaRegistryContextSubject resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSubjectName
   *   A fully-qualified path representing project_location_schema_registry_context_subject resource.
   * @returns {string} A string representing the subject.
   */
  matchSubjectFromProjectLocationSchemaRegistryContextSubjectName(projectLocationSchemaRegistryContextSubjectName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectPathTemplate.match(projectLocationSchemaRegistryContextSubjectName).subject;
  }

  /**
   * Return a fully-qualified projectLocationSchemaRegistryContextSubjectVersions resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} schema_registry
   * @param {string} context
   * @param {string} subject
   * @param {string} version
   * @returns {string} Resource name string.
   */
  projectLocationSchemaRegistryContextSubjectVersionsPath(project:string,location:string,schemaRegistry:string,context:string,subject:string,version:string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectVersionsPathTemplate.render({
      project: project,
      location: location,
      schema_registry: schemaRegistry,
      context: context,
      subject: subject,
      version: version,
    });
  }

  /**
   * Parse the project from ProjectLocationSchemaRegistryContextSubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_context_subject_versions resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromProjectLocationSchemaRegistryContextSubjectVersionsName(projectLocationSchemaRegistryContextSubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectVersionsPathTemplate.match(projectLocationSchemaRegistryContextSubjectVersionsName).project;
  }

  /**
   * Parse the location from ProjectLocationSchemaRegistryContextSubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_context_subject_versions resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromProjectLocationSchemaRegistryContextSubjectVersionsName(projectLocationSchemaRegistryContextSubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectVersionsPathTemplate.match(projectLocationSchemaRegistryContextSubjectVersionsName).location;
  }

  /**
   * Parse the schema_registry from ProjectLocationSchemaRegistryContextSubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_context_subject_versions resource.
   * @returns {string} A string representing the schema_registry.
   */
  matchSchemaRegistryFromProjectLocationSchemaRegistryContextSubjectVersionsName(projectLocationSchemaRegistryContextSubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectVersionsPathTemplate.match(projectLocationSchemaRegistryContextSubjectVersionsName).schema_registry;
  }

  /**
   * Parse the context from ProjectLocationSchemaRegistryContextSubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_context_subject_versions resource.
   * @returns {string} A string representing the context.
   */
  matchContextFromProjectLocationSchemaRegistryContextSubjectVersionsName(projectLocationSchemaRegistryContextSubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectVersionsPathTemplate.match(projectLocationSchemaRegistryContextSubjectVersionsName).context;
  }

  /**
   * Parse the subject from ProjectLocationSchemaRegistryContextSubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_context_subject_versions resource.
   * @returns {string} A string representing the subject.
   */
  matchSubjectFromProjectLocationSchemaRegistryContextSubjectVersionsName(projectLocationSchemaRegistryContextSubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectVersionsPathTemplate.match(projectLocationSchemaRegistryContextSubjectVersionsName).subject;
  }

  /**
   * Parse the version from ProjectLocationSchemaRegistryContextSubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_context_subject_versions resource.
   * @returns {string} A string representing the version.
   */
  matchVersionFromProjectLocationSchemaRegistryContextSubjectVersionsName(projectLocationSchemaRegistryContextSubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectVersionsPathTemplate.match(projectLocationSchemaRegistryContextSubjectVersionsName).version;
  }

  /**
   * Return a fully-qualified projectLocationSchemaRegistryContextSubjects resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} schema_registry
   * @param {string} context
   * @param {string} subject
   * @returns {string} Resource name string.
   */
  projectLocationSchemaRegistryContextSubjectsPath(project:string,location:string,schemaRegistry:string,context:string,subject:string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectsPathTemplate.render({
      project: project,
      location: location,
      schema_registry: schemaRegistry,
      context: context,
      subject: subject,
    });
  }

  /**
   * Parse the project from ProjectLocationSchemaRegistryContextSubjects resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSubjectsName
   *   A fully-qualified path representing project_location_schema_registry_context_subjects resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromProjectLocationSchemaRegistryContextSubjectsName(projectLocationSchemaRegistryContextSubjectsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectsPathTemplate.match(projectLocationSchemaRegistryContextSubjectsName).project;
  }

  /**
   * Parse the location from ProjectLocationSchemaRegistryContextSubjects resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSubjectsName
   *   A fully-qualified path representing project_location_schema_registry_context_subjects resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromProjectLocationSchemaRegistryContextSubjectsName(projectLocationSchemaRegistryContextSubjectsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectsPathTemplate.match(projectLocationSchemaRegistryContextSubjectsName).location;
  }

  /**
   * Parse the schema_registry from ProjectLocationSchemaRegistryContextSubjects resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSubjectsName
   *   A fully-qualified path representing project_location_schema_registry_context_subjects resource.
   * @returns {string} A string representing the schema_registry.
   */
  matchSchemaRegistryFromProjectLocationSchemaRegistryContextSubjectsName(projectLocationSchemaRegistryContextSubjectsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectsPathTemplate.match(projectLocationSchemaRegistryContextSubjectsName).schema_registry;
  }

  /**
   * Parse the context from ProjectLocationSchemaRegistryContextSubjects resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSubjectsName
   *   A fully-qualified path representing project_location_schema_registry_context_subjects resource.
   * @returns {string} A string representing the context.
   */
  matchContextFromProjectLocationSchemaRegistryContextSubjectsName(projectLocationSchemaRegistryContextSubjectsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectsPathTemplate.match(projectLocationSchemaRegistryContextSubjectsName).context;
  }

  /**
   * Parse the subject from ProjectLocationSchemaRegistryContextSubjects resource.
   *
   * @param {string} projectLocationSchemaRegistryContextSubjectsName
   *   A fully-qualified path representing project_location_schema_registry_context_subjects resource.
   * @returns {string} A string representing the subject.
   */
  matchSubjectFromProjectLocationSchemaRegistryContextSubjectsName(projectLocationSchemaRegistryContextSubjectsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryContextSubjectsPathTemplate.match(projectLocationSchemaRegistryContextSubjectsName).subject;
  }

  /**
   * Return a fully-qualified projectLocationSchemaRegistryMode resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} schema_registry
   * @returns {string} Resource name string.
   */
  projectLocationSchemaRegistryModePath(project:string,location:string,schemaRegistry:string) {
    return this.pathTemplates.projectLocationSchemaRegistryModePathTemplate.render({
      project: project,
      location: location,
      schema_registry: schemaRegistry,
    });
  }

  /**
   * Parse the project from ProjectLocationSchemaRegistryMode resource.
   *
   * @param {string} projectLocationSchemaRegistryModeName
   *   A fully-qualified path representing project_location_schema_registry_mode resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromProjectLocationSchemaRegistryModeName(projectLocationSchemaRegistryModeName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryModePathTemplate.match(projectLocationSchemaRegistryModeName).project;
  }

  /**
   * Parse the location from ProjectLocationSchemaRegistryMode resource.
   *
   * @param {string} projectLocationSchemaRegistryModeName
   *   A fully-qualified path representing project_location_schema_registry_mode resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromProjectLocationSchemaRegistryModeName(projectLocationSchemaRegistryModeName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryModePathTemplate.match(projectLocationSchemaRegistryModeName).location;
  }

  /**
   * Parse the schema_registry from ProjectLocationSchemaRegistryMode resource.
   *
   * @param {string} projectLocationSchemaRegistryModeName
   *   A fully-qualified path representing project_location_schema_registry_mode resource.
   * @returns {string} A string representing the schema_registry.
   */
  matchSchemaRegistryFromProjectLocationSchemaRegistryModeName(projectLocationSchemaRegistryModeName: string) {
    return this.pathTemplates.projectLocationSchemaRegistryModePathTemplate.match(projectLocationSchemaRegistryModeName).schema_registry;
  }

  /**
   * Return a fully-qualified projectLocationSchemaRegistrySchemas resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} schema_registry
   * @param {string} schema
   * @returns {string} Resource name string.
   */
  projectLocationSchemaRegistrySchemasPath(project:string,location:string,schemaRegistry:string,schema:string) {
    return this.pathTemplates.projectLocationSchemaRegistrySchemasPathTemplate.render({
      project: project,
      location: location,
      schema_registry: schemaRegistry,
      schema: schema,
    });
  }

  /**
   * Parse the project from ProjectLocationSchemaRegistrySchemas resource.
   *
   * @param {string} projectLocationSchemaRegistrySchemasName
   *   A fully-qualified path representing project_location_schema_registry_schemas resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromProjectLocationSchemaRegistrySchemasName(projectLocationSchemaRegistrySchemasName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySchemasPathTemplate.match(projectLocationSchemaRegistrySchemasName).project;
  }

  /**
   * Parse the location from ProjectLocationSchemaRegistrySchemas resource.
   *
   * @param {string} projectLocationSchemaRegistrySchemasName
   *   A fully-qualified path representing project_location_schema_registry_schemas resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromProjectLocationSchemaRegistrySchemasName(projectLocationSchemaRegistrySchemasName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySchemasPathTemplate.match(projectLocationSchemaRegistrySchemasName).location;
  }

  /**
   * Parse the schema_registry from ProjectLocationSchemaRegistrySchemas resource.
   *
   * @param {string} projectLocationSchemaRegistrySchemasName
   *   A fully-qualified path representing project_location_schema_registry_schemas resource.
   * @returns {string} A string representing the schema_registry.
   */
  matchSchemaRegistryFromProjectLocationSchemaRegistrySchemasName(projectLocationSchemaRegistrySchemasName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySchemasPathTemplate.match(projectLocationSchemaRegistrySchemasName).schema_registry;
  }

  /**
   * Parse the schema from ProjectLocationSchemaRegistrySchemas resource.
   *
   * @param {string} projectLocationSchemaRegistrySchemasName
   *   A fully-qualified path representing project_location_schema_registry_schemas resource.
   * @returns {string} A string representing the schema.
   */
  matchSchemaFromProjectLocationSchemaRegistrySchemasName(projectLocationSchemaRegistrySchemasName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySchemasPathTemplate.match(projectLocationSchemaRegistrySchemasName).schema;
  }

  /**
   * Return a fully-qualified projectLocationSchemaRegistrySubject resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} schema_registry
   * @param {string} subject
   * @returns {string} Resource name string.
   */
  projectLocationSchemaRegistrySubjectPath(project:string,location:string,schemaRegistry:string,subject:string) {
    return this.pathTemplates.projectLocationSchemaRegistrySubjectPathTemplate.render({
      project: project,
      location: location,
      schema_registry: schemaRegistry,
      subject: subject,
    });
  }

  /**
   * Parse the project from ProjectLocationSchemaRegistrySubject resource.
   *
   * @param {string} projectLocationSchemaRegistrySubjectName
   *   A fully-qualified path representing project_location_schema_registry_subject resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromProjectLocationSchemaRegistrySubjectName(projectLocationSchemaRegistrySubjectName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySubjectPathTemplate.match(projectLocationSchemaRegistrySubjectName).project;
  }

  /**
   * Parse the location from ProjectLocationSchemaRegistrySubject resource.
   *
   * @param {string} projectLocationSchemaRegistrySubjectName
   *   A fully-qualified path representing project_location_schema_registry_subject resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromProjectLocationSchemaRegistrySubjectName(projectLocationSchemaRegistrySubjectName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySubjectPathTemplate.match(projectLocationSchemaRegistrySubjectName).location;
  }

  /**
   * Parse the schema_registry from ProjectLocationSchemaRegistrySubject resource.
   *
   * @param {string} projectLocationSchemaRegistrySubjectName
   *   A fully-qualified path representing project_location_schema_registry_subject resource.
   * @returns {string} A string representing the schema_registry.
   */
  matchSchemaRegistryFromProjectLocationSchemaRegistrySubjectName(projectLocationSchemaRegistrySubjectName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySubjectPathTemplate.match(projectLocationSchemaRegistrySubjectName).schema_registry;
  }

  /**
   * Parse the subject from ProjectLocationSchemaRegistrySubject resource.
   *
   * @param {string} projectLocationSchemaRegistrySubjectName
   *   A fully-qualified path representing project_location_schema_registry_subject resource.
   * @returns {string} A string representing the subject.
   */
  matchSubjectFromProjectLocationSchemaRegistrySubjectName(projectLocationSchemaRegistrySubjectName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySubjectPathTemplate.match(projectLocationSchemaRegistrySubjectName).subject;
  }

  /**
   * Return a fully-qualified projectLocationSchemaRegistrySubjectVersions resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} schema_registry
   * @param {string} subject
   * @param {string} version
   * @returns {string} Resource name string.
   */
  projectLocationSchemaRegistrySubjectVersionsPath(project:string,location:string,schemaRegistry:string,subject:string,version:string) {
    return this.pathTemplates.projectLocationSchemaRegistrySubjectVersionsPathTemplate.render({
      project: project,
      location: location,
      schema_registry: schemaRegistry,
      subject: subject,
      version: version,
    });
  }

  /**
   * Parse the project from ProjectLocationSchemaRegistrySubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistrySubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_subject_versions resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromProjectLocationSchemaRegistrySubjectVersionsName(projectLocationSchemaRegistrySubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySubjectVersionsPathTemplate.match(projectLocationSchemaRegistrySubjectVersionsName).project;
  }

  /**
   * Parse the location from ProjectLocationSchemaRegistrySubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistrySubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_subject_versions resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromProjectLocationSchemaRegistrySubjectVersionsName(projectLocationSchemaRegistrySubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySubjectVersionsPathTemplate.match(projectLocationSchemaRegistrySubjectVersionsName).location;
  }

  /**
   * Parse the schema_registry from ProjectLocationSchemaRegistrySubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistrySubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_subject_versions resource.
   * @returns {string} A string representing the schema_registry.
   */
  matchSchemaRegistryFromProjectLocationSchemaRegistrySubjectVersionsName(projectLocationSchemaRegistrySubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySubjectVersionsPathTemplate.match(projectLocationSchemaRegistrySubjectVersionsName).schema_registry;
  }

  /**
   * Parse the subject from ProjectLocationSchemaRegistrySubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistrySubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_subject_versions resource.
   * @returns {string} A string representing the subject.
   */
  matchSubjectFromProjectLocationSchemaRegistrySubjectVersionsName(projectLocationSchemaRegistrySubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySubjectVersionsPathTemplate.match(projectLocationSchemaRegistrySubjectVersionsName).subject;
  }

  /**
   * Parse the version from ProjectLocationSchemaRegistrySubjectVersions resource.
   *
   * @param {string} projectLocationSchemaRegistrySubjectVersionsName
   *   A fully-qualified path representing project_location_schema_registry_subject_versions resource.
   * @returns {string} A string representing the version.
   */
  matchVersionFromProjectLocationSchemaRegistrySubjectVersionsName(projectLocationSchemaRegistrySubjectVersionsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySubjectVersionsPathTemplate.match(projectLocationSchemaRegistrySubjectVersionsName).version;
  }

  /**
   * Return a fully-qualified projectLocationSchemaRegistrySubjects resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} schema_registry
   * @param {string} subject
   * @returns {string} Resource name string.
   */
  projectLocationSchemaRegistrySubjectsPath(project:string,location:string,schemaRegistry:string,subject:string) {
    return this.pathTemplates.projectLocationSchemaRegistrySubjectsPathTemplate.render({
      project: project,
      location: location,
      schema_registry: schemaRegistry,
      subject: subject,
    });
  }

  /**
   * Parse the project from ProjectLocationSchemaRegistrySubjects resource.
   *
   * @param {string} projectLocationSchemaRegistrySubjectsName
   *   A fully-qualified path representing project_location_schema_registry_subjects resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromProjectLocationSchemaRegistrySubjectsName(projectLocationSchemaRegistrySubjectsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySubjectsPathTemplate.match(projectLocationSchemaRegistrySubjectsName).project;
  }

  /**
   * Parse the location from ProjectLocationSchemaRegistrySubjects resource.
   *
   * @param {string} projectLocationSchemaRegistrySubjectsName
   *   A fully-qualified path representing project_location_schema_registry_subjects resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromProjectLocationSchemaRegistrySubjectsName(projectLocationSchemaRegistrySubjectsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySubjectsPathTemplate.match(projectLocationSchemaRegistrySubjectsName).location;
  }

  /**
   * Parse the schema_registry from ProjectLocationSchemaRegistrySubjects resource.
   *
   * @param {string} projectLocationSchemaRegistrySubjectsName
   *   A fully-qualified path representing project_location_schema_registry_subjects resource.
   * @returns {string} A string representing the schema_registry.
   */
  matchSchemaRegistryFromProjectLocationSchemaRegistrySubjectsName(projectLocationSchemaRegistrySubjectsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySubjectsPathTemplate.match(projectLocationSchemaRegistrySubjectsName).schema_registry;
  }

  /**
   * Parse the subject from ProjectLocationSchemaRegistrySubjects resource.
   *
   * @param {string} projectLocationSchemaRegistrySubjectsName
   *   A fully-qualified path representing project_location_schema_registry_subjects resource.
   * @returns {string} A string representing the subject.
   */
  matchSubjectFromProjectLocationSchemaRegistrySubjectsName(projectLocationSchemaRegistrySubjectsName: string) {
    return this.pathTemplates.projectLocationSchemaRegistrySubjectsPathTemplate.match(projectLocationSchemaRegistrySubjectsName).subject;
  }

  /**
   * Return a fully-qualified schemaContext resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} schema_registry
   * @param {string} context
   * @returns {string} Resource name string.
   */
  schemaContextPath(project:string,location:string,schemaRegistry:string,context:string) {
    return this.pathTemplates.schemaContextPathTemplate.render({
      project: project,
      location: location,
      schema_registry: schemaRegistry,
      context: context,
    });
  }

  /**
   * Parse the project from SchemaContext resource.
   *
   * @param {string} schemaContextName
   *   A fully-qualified path representing SchemaContext resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromSchemaContextName(schemaContextName: string) {
    return this.pathTemplates.schemaContextPathTemplate.match(schemaContextName).project;
  }

  /**
   * Parse the location from SchemaContext resource.
   *
   * @param {string} schemaContextName
   *   A fully-qualified path representing SchemaContext resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromSchemaContextName(schemaContextName: string) {
    return this.pathTemplates.schemaContextPathTemplate.match(schemaContextName).location;
  }

  /**
   * Parse the schema_registry from SchemaContext resource.
   *
   * @param {string} schemaContextName
   *   A fully-qualified path representing SchemaContext resource.
   * @returns {string} A string representing the schema_registry.
   */
  matchSchemaRegistryFromSchemaContextName(schemaContextName: string) {
    return this.pathTemplates.schemaContextPathTemplate.match(schemaContextName).schema_registry;
  }

  /**
   * Parse the context from SchemaContext resource.
   *
   * @param {string} schemaContextName
   *   A fully-qualified path representing SchemaContext resource.
   * @returns {string} A string representing the context.
   */
  matchContextFromSchemaContextName(schemaContextName: string) {
    return this.pathTemplates.schemaContextPathTemplate.match(schemaContextName).context;
  }

  /**
   * Return a fully-qualified schemaRegistry resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} schema_registry
   * @returns {string} Resource name string.
   */
  schemaRegistryPath(project:string,location:string,schemaRegistry:string) {
    return this.pathTemplates.schemaRegistryPathTemplate.render({
      project: project,
      location: location,
      schema_registry: schemaRegistry,
    });
  }

  /**
   * Parse the project from SchemaRegistry resource.
   *
   * @param {string} schemaRegistryName
   *   A fully-qualified path representing SchemaRegistry resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromSchemaRegistryName(schemaRegistryName: string) {
    return this.pathTemplates.schemaRegistryPathTemplate.match(schemaRegistryName).project;
  }

  /**
   * Parse the location from SchemaRegistry resource.
   *
   * @param {string} schemaRegistryName
   *   A fully-qualified path representing SchemaRegistry resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromSchemaRegistryName(schemaRegistryName: string) {
    return this.pathTemplates.schemaRegistryPathTemplate.match(schemaRegistryName).location;
  }

  /**
   * Parse the schema_registry from SchemaRegistry resource.
   *
   * @param {string} schemaRegistryName
   *   A fully-qualified path representing SchemaRegistry resource.
   * @returns {string} A string representing the schema_registry.
   */
  matchSchemaRegistryFromSchemaRegistryName(schemaRegistryName: string) {
    return this.pathTemplates.schemaRegistryPathTemplate.match(schemaRegistryName).schema_registry;
  }

  /**
   * Terminate the gRPC channel and close the client.
   *
   * The client will no longer be usable and all future behavior is undefined.
   * @returns {Promise} A promise that resolves when the client is closed.
   */
  close(): Promise<void> {
    if (this.managedSchemaRegistryStub && !this._terminated) {
      return this.managedSchemaRegistryStub.then(stub => {
        this._log.info('ending gRPC channel');
        this._terminated = true;
        stub.close();
        this.locationsClient.close().catch(err => {throw err});
      });
    }
    return Promise.resolve();
  }
}